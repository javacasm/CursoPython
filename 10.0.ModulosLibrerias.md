# Modulos

Como hemos visto un módulo no es otra cosa que una colección de código, clases, variables y funciones que nosotros podemos utilizar desde nuestros programas. Lo importaremos al principio del programa y a partir de ahí podremos utilizarlo en nuestro código.

Existen diferentes formas de importación según queramos importar todo el módulo o solamente unas clases del mismo. 

Con *import módulo* lo importamos completo. Para usarlo usaremos sus clases, funciones o variables precedidas del nombre del módulo, al que llamaremos *espacio de nombres* (namespace):

```python

import os

ficheros = os.listdir('/tmp')
os.rename('fichero1', 'fichero2')
```

El codigo dentro del módulo se agrupa según el espacio de nombres, por ejemplo *os.path.isfile()*

Si queremos importar sólo alguna parte del código podemos usar la estructura de *from ... import clase*, pudiendo evitar la referencia al módulo. Por ejemplo:

```python
from os import path
path.isfile('test')
```
Para agilizar el uso del código de los módulos podemos definir un alias con la palabra reservada *as* en cualquier de los formatos (import o form ... import)

```python
import os.path as p
p.isfile('test')
```
### Importando nuestro código

Cuando creamos un programa cuyo código está distribuido entre varios ficheros, podemos importar la funcionalidad como si un módulo se tratara, haciendo simplemente *import fichero* (sin la extensión .py)

Accederemos a la funcionalidad con *fichero.funcion* del mismo modo.

Puedes probarlo importando el código del fichero de las 20 preguntas y usándolo desde tu propio programa.

Cuando hacemos esto tenemos que distinguir si estamos usando el código como un módulo o como un programa principal. 

En la siguiente sección vamos a ver cómo hacerlo.

### Propiedades de los módulos

Cuando ejecutamos un intérprete Python existen una [serie de variables](https://docs.python.org/3/reference/import.html?highlight=__file__#import-related-module-attributes) con valores características, como por ejemplo:

* *__name__* que se refiere al nombre completo del módulo en ejecución. Cuando ejecutamos un fichero, el valor de este atributo será '__main__', cuando importamos un módulo será el nombre del módulo.

Podemos aprovechar esto para saber si nuestro código se está ejecutando directamente o a través de una importación.

```python
if __name__ == '__main__':
    myMain()
else:
    print('Me han importado')
```

* *__version__ * nos dice la versión de un módulo usando

```python
import os
os.__version__
```
* *__file__* nombre del fichero

Vamos a probarlo. Creamos un fichero *Prop_modulos.py* con este contenido:

```python
'''
Modulo de prueba
'''


try:
    print(f'__name__: {__name__}')
    print(f'__file__: {__file__}')
    print(f'__loader__: {__loader__}')
    print(f'__package__: {__package__}')
    print(f'__path__: {__path__}')    
except Exception as e:
    print(f'Error: {e}')
```

Si lo ejecutamos con *python3 Prop_modulos* obtenemos:
```
__name__: __main__
__file__: Prop_modulos.py
__loader__: <_frozen_importlib_external.SourceFileLoader object at 0x7fcb9d9d02b0>
__package__: None
Error: name '__path__' is not defined
```

En cambio si desde un intérprete python3 hacemos *import Prop_modulos* veremos:

```
>>> import Prop_modulos
__name__: Prop_modulos
__file__: /home/javacasm/Dropbox/Cursos/CursoPython/codigo/Prop_modulos.py
__loader__: <_frozen_importlib_external.SourceFileLoader object at 0x7fd7a67433c8>
__package__: 
Error: name '__path__' is not defined
```

Si ahora hacemos help(Prop_modulos) veremos que nos muestra parte de esta información.

