## Módulos y paquetes

Como hemos visto, un módulo o paquete no es otra cosa que una colección de código, clases, variables y funciones que podemos utilizar desde nuestros programas. Lo importamos al principio del programa y a partir de ahí podremos utilizarlo en nuestro código.

Por **módulo** entendemos un fichero que incluye código y un **paquete** será un conjunto de módulos que se suelen incluir en un directorio.


```
paquete
├── modulo1.py
├── modulo2.py
└── modulo3.py

```
Y dentro de cada fichero moduloX.py tendríamos funciones, clases, ...

Existen diferentes formas de importación según queramos importar todo el paquete o solamente unos módulos del mismo. 

Con *"import paquete"* lo importamos completo. Para usarlo usaremos sus clases, funciones o variables precedidas del nombre del módulo, al que llamaremos *espacio de nombres* (namespace):

```python

import os

ficheros = os.listdir('/tmp')
os.rename('fichero1', 'fichero2')
```

En nuestro "paquete" imaginario sería:

```python
import paquete

paquete.modulo1.funcion1()
```

El código dentro del módulo se agrupa según el espacio de nombres, por ejemplo *os.path.isfile()*.

Si queremos importar sólo alguna parte del código podemos usar la estructura de *"from ... import clase"*, pudiendo evitar la referencia al módulo. Por ejemplo:

```python
from os import path
path.isfile('test')
```
Para agilizar el uso del código de los módulos podemos definir un alias con la palabra reservada *"as"* en cualquier de los formatos (*import* o *form ... import*)

```python
import os.path as p
p.isfile('test')
```


En nuestro ejemplo, si sólo queremos usar el "modulo2" de "paquete" haríamos

```python
from paquete import modulo2

...
```

### ¿Dónde se buscan los módulos?

Cuando importamos un paquete ¿dónde se busca este paquete?:

1. En primer lugar se busca en la librería estándar de python, es decir entre todos los paquetes que incluye la versión que estamos usando
2. Después se busca en todos los directorios incluidos en "sys.path", donde se incluyen en este orden:
    a. El directorio actual donde estamos ejecutando nuestro código
    b. Los directorios de instalación de python y algunos otros según un orden concreto.

Podemos ver lo que incluye nuestro *sys.path* con este sencillo código:

```python
>>> import sys
>>> for p in sys.path:
...     print(p)
... 

/usr/lib/python36.zip
/usr/lib/python3.6
/usr/lib/python3.6/lib-dynload
/home/javacasm/.local/lib/python3.6/site-packages
/home/javacasm/Dropbox/Cursos/Drones/DJITelloPy
/usr/local/lib/python3.6/dist-packages
/usr/lib/python3/dist-packages
``` 

El estar ordenado de esta manera hace que podamos incluir un paquete que sobreescriba otro. Por ejemplo poniendo un paquete "os" en el directorio actual, al hacer "import os" se importaría el nuestro.

### Importando nuestro código

Cuando creamos un programa cuyo código está distribuido entre varios ficheros, podemos importar la funcionalidad como si un módulo se tratara, haciendo simplemente *import fichero* (sin la extensión .py)

Accederemos a la funcionalidad con *fichero.funcion* del mismo modo.

Puedes probarlo importando el código del fichero de las 20 preguntas y usándolo desde tu propio programa.

Cuando hacemos esto tenemos que distinguir si estamos usando el código como un módulo o como un programa principal. 

En la siguiente sección vamos a ver cómo hacerlo.

### Propiedades de los módulos

Cuando ejecutamos un intérprete Python existen una [serie de variables](https://docs.python.org/3/reference/import.html?highlight=__file__#import-related-module-attributes) con valores características, como por ejemplo:

* *__name__* que se refiere al nombre completo del módulo en ejecución. Cuando ejecutamos un fichero, el valor de este atributo será '__main__', cuando importamos un módulo será el nombre del módulo.

Podemos aprovechar esto para saber si nuestro código se está ejecutando directamente o a través de una importación.

```python
if __name__ == '__main__':
    myMain()
else:
    print('Me han importado')
```

* *__version__* nos dice la versión de un módulo usando

```python
import os
os.__version__
```
* *__file__* nombre del fichero

Vamos a probarlo. Creamos un fichero *Prop_modulos.py* con este contenido:

```python
'''
Módulo de prueba
'''

try:
    print(f'__name__: {__name__}')
    print(f'__file__: {__file__}')
    print(f'__loader__: {__loader__}')
    print(f'__package__: {__package__}')
    print(f'__path__: {__path__}')    
except Exception as e:
    print(f'Error: {e}')
```

Si lo ejecutamos con *python3 Prop_modulos* obtenemos:
```
__name__: __main__
__file__: Prop_modulos.py
__loader__: <_frozen_importlib_external.SourceFileLoader object at 0x7fcb9d9d02b0>
__package__: None
Error: name '__path__' is not defined
```

En cambio si desde un intérprete python3 hacemos *import Prop_modulos* veremos:

```
>>> import Prop_modulos
__name__: Prop_modulos
__file__: /home/javacasm/Dropbox/Cursos/CursoPython/codigo/Prop_modulos.py
__loader__: <_frozen_importlib_external.SourceFileLoader object at 0x7fd7a67433c8>
__package__: 
Error: name '__path__' is not defined
```

Si ahora hacemos help(Prop_modulos) veremos que nos muestra parte de esta información.


[![Vídeo:  Importando y usando módulos en Python](https://img.youtube.com/vi/N92DU1TQsoU/0.jpg)](https://drive.google.com/file/d/1tWacnzAg7RC0VvT-aVqFaWoHAllvoonT/view?usp=drive_link)


[Vídeo:  Importando y usando módulos en Python](https://drive.google.com/file/d/1tWacnzAg7RC0VvT-aVqFaWoHAllvoonT/view?usp=drive_link)

